#include <p18f4520.h>
#include <htc.h>
#include "oled.h"
#include <string.h>
#include <delays.h>

void I2CInit(void)
{
    SSPCON1 = 0b00101000; // Control register 
    // Enables the serial port and configures the SDA and SCL pins as the serial port pins
    // I2C Master mode, clock = FOSC/(4 * (SSPADD + 1))
    SSPCON2 = 0b01100000; // Control register no ack from display
    SSPSTAT = 0b10000000; // Status register  
    TXSTA = 0b1000000;
    ABDOVF = 0b01010000;
    SSPADD = 0x09; // SSP in Master mode -> baud rate generator Fosc=4MHz -> Fcy=1MHz -> BRG=0x09 -> Fscl=100kHz -> SSPADD = (FCY/FSCL) -1
    SSPMSK = 0x00; // Address mask The received address bit n is not used to detect I2C address match
}

void I2CStart(void)
{
    SSPCON2bits.SEN = 1; // I2C Start condition
    while(SSPCON2bits.SEN); // Wait the required start time before any other operation takes place
}

void I2CStop(void)
{
    SSPCON2bits.PEN = 1;
    while(SSPCON2bits.PEN); // Stop I2C
}

void I2CSend(char data)
{
    SSPBUF = data; // Serial Receive/Transmit Buffer
    while(SSPSTATbits.RW); // Transmit is in progress
}

void OLED_Init(void)
{
    OLED_command(DISPLAYOFF);         // 0xAE
    Delay1KTCYx(1);                   // tempo = 10 * 1000 * Tcycle = 4ms -> Tcycle = (1/Fosc) * 4 = 4µs

    OLED_command(SETDISPLAYCLOCKDIV); // 0xD5
    OLED_command(0x80);               // the suggested ratio 0x80
    Delay1KTCYx(1);

    // Hardware configuration

    OLED_command(SETSTARTLINE | 0x00); // line #0
    Delay1KTCYx(1);

    OLED_command(SEGREMAP | 0x1);     // Symétrie horizontal
    Delay1KTCYx(1);

    #ifdef OLED_HEIGHT == 64
        OLED_command(SETMULTIPLEX);       // 0xA8
        OLED_command(0x3F);               // 0x1F = 128x32 pixels / 0x3F = 128x64 pixels
        Delay1KTCYx(1);
    #elif OLED_HEIGHT == 32
        OLED_command(SETMULTIPLEX);       // 0xA8
        OLED_command(0x1F);               // 0x1F = 128x32 pixels / 0x3F = 128x64 pixels
        Delay1KTCYx(1);
    #endif


    OLED_command(SETDISPLAYOFFSET);   // 0xD3
    OLED_command(0);                  // no offset  
    Delay1KTCYx(1);

    OLED_command(SETCOMPINS);         // 0xDA
    OLED_command(0x12);               // Alternative COM pin configuration -> source du problème 1 pixel sur 2
    Delay1KTCYx(1);

    // 

    OLED_command(CHARGEPUMP);         // 0x8D
    OLED_command(0x10);               // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT ELSE 0x14
    Delay1KTCYx(1);

    OLED_command(MEMORYMODE);         // 0x20
    OLED_command(HORIZONTAL);         // 0x0 Horizontal
    Delay1KTCYx(1);

    OLED_command(COMSCANDEC);
    Delay1KTCYx(1);
    
    OLED_command(SETCONTRAST);        // 0x81
    OLED_command(0x8F);
    Delay1KTCYx(1);

    OLED_command(SETPRECHARGE);       // 0xd9
    OLED_command(0x22); // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT ELSE 0xF1
    Delay1KTCYx(1);

    OLED_command(SETVCOMDETECT);      // 0xDB
    OLED_command(0x40);
    Delay1KTCYx(1);

    OLED_command(DISPLAYALLON_RESUME);// 0xA4
    Delay1KTCYx(1);

    OLED_command(NORMALDISPLAY);      // 0xA6
    Delay1KTCYx(1);

    OLED_command(DISPLAYON);
    Delay1KTCYx(1);

    OLED_command(PAGEADDR); // This display has 8 pages (64 pixels/bits vertical)
    OLED_command(0);
    OLED_command(7);
    Delay1KTCYx(1);

    OLED_command(COLUMNADDR); // This display has 128 columns (128 pixels/bits horizontal)
    OLED_command(0);
    OLED_command(127);
    Delay1KTCYx(1);

    OLED_clear();
}

void OLED_command(char command)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_CMD); // Send command incomming
    I2CSend(command); // Send command
    I2CStop();
}

void OLED_data(char data)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_DATA); // Send data incomming
    I2CSend(data); // Send data
    I2CStop();
}

void OLED_clear(void)
{
   int i;

   I2CStart();
   I2CSend(I2C_ADDRESS);
   I2CSend(I2C_DATA);

   for(i=0; i < 1023; i++) // 1024 = 128 * 64/8
   {
       I2CSend(0x00);
   }

   I2CStop();
}

void OLED_char(char character, unsigned char font)
{
    unsigned char i;

    if(font == FONT_5X8)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 5; i++)
        {
            I2CSend(FONT_5x8[character - 0x20][i]);
        }
        I2CSend(0x00); // pour espacer les caractères

        I2CStop();
    }

    else if(font == FONT_8X16)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 16; i++)
        {
            I2CSend(FONT_8x16[character - 0x20][i]);
        }
        I2CSend(0x00); // pour espacer les caractères
        I2CSend(0x00);
        
        I2CStop();
    }
}

void OLED_string(char* string, unsigned char x, unsigned char y, unsigned char font)
{
    unsigned char i = 0;

    OLED_pos(x, y);

    while(string[i] != '\0')
    {
        if(font == FONT_5X8)
        {
            OLED_char(string[i++], FONT_5X8);
        }

        else if(font == FONT_8X16)
        {
            OLED_command(PAGEADDR); // set page address
            Delay1KTCYx(1);
            OLED_command(y); // start at page 0
            Delay1KTCYx(1);
            OLED_command(y+1); // end at page 1
            Delay1KTCYx(1);
            OLED_command(MEMORYMODE);
            OLED_command(VERTICAL); // Vertical adressing mode
            
            OLED_char(string[i++], FONT_8X16);

            OLED_command(PAGEADDR); // set page address
            Delay1KTCYx(1);
            OLED_command(0); // start at page 0
            Delay1KTCYx(1);
            OLED_command(7); // end at page 7
            Delay1KTCYx(1);
            OLED_command(MEMORYMODE);
            OLED_command(HORIZONTAL); // Vertical adressing mode
        }
    }
}

// 128 columns + 4 rows
// xmin=0, xmax=127
// ymin=0, ymax=3
// 4 pages / 1 page = 1 byte with LSB high and MSB low
void OLED_pos(char x, char y)
{
    char low_column=0;
    char high_column=0;
    char page=0;

    page=y|0xB0;
    low_column=x&0x0F;
    high_column=x&0xF0;
    high_column>>=4;
    high_column|=0x10;

    OLED_command(MEMORYMODE);
    OLED_command(PAGE); // Page adressing mode
    Delay1KTCYx(1);
    OLED_command(low_column); // Set lower colomn
    Delay1KTCYx(1);
    OLED_command(high_column); // Set higher colomn
    Delay1KTCYx(1);
    OLED_command(page); // Set RAM page
    Delay1KTCYx(1);
    OLED_command(MEMORYMODE);
    OLED_command(HORIZONTAL); // Horizontal adressing mode
    Delay1KTCYx(1);
}

void OLED_bmp(char sel)
{
    int i = 0;

    if (sel == LOGO)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 1023; i++)
        {
            I2CSend(FONT_LOGO[i]);
        }

        I2CStop();
    }
}

void OLED_invert(void)
{
    Delay1KTCYx(1);
    OLED_command(INVERTDISPLAY);
}

void OLED_rscroll(void)
{
    Delay1KTCYx(1);
    OLED_command(0x26);
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0x2F); // Activate scroll
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0x2E); // Desactivate scroll
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0XFF);
    Delay1KTCYx(1);
    OLED_command(0x2F); //Activate scroll
}

void OLED_lscroll(void)
{
    Delay1KTCYx(1);
    OLED_command(0x27);
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0x2F); // Activate scroll
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0x2E); // Desactivate scroll
    Delay1KTCYx(1);
    OLED_command(0X00);
    Delay1KTCYx(1);
    OLED_command(0XFF);
    Delay1KTCYx(1);
    OLED_command(0x2F); //Activate scroll
}

void OLED_stopscroll(void)
{
    Delay1KTCYx(1);
    OLED_command(0x2E);
}
