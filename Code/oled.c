#include <p18f4520.h>
#include "oled.h"
#include <delays.h>

void I2CInit(void)
{
    SSPCON1 = 0b00101000; // Control register 
    // Enables the serial port and configures the SDA and SCL pins as the serial port pins
    // I2C Master mode, clock = FOSC/(4 * (SSPADD + 1))
    SSPCON2 = 0b01100000; // Control register no ack from display
    SSPSTAT = 0b10000000; // Status register  
    TXSTA = 0b1000000;
    ABDOVF = 0b01010000;
    SSPADD = 0x09; // SSP in Master mode -> baud rate generator Fosc=4MHz -> Fcy=1MHz -> BRG=0x09 -> Fscl=100kHz -> SSPADD = (FCY/FSCL) -1
    SSPMSK = 0x00; // Address mask The received address bit n is not used to detect I2C address match
}

void I2CStart(void)
{
    SSPCON2bits.SEN = 1; // I2C Start condition
    while(SSPCON2bits.SEN); // Wait the required start time before any other operation takes place
}

void I2CStop(void)
{
    SSPCON2bits.PEN = 1;
    while(SSPCON2bits.PEN); // Stop I2C
}

void I2CSend(char data)
{
    SSPBUF = data; // Serial Receive/Transmit Buffer
    while(SSPSTATbits.RW); // Transmit is in progress
}

void OLED_Init(void)
{
    OLED_command(DISPLAYOFF);         // 0xAE                 

    OLED_command(SETDISPLAYCLOCKDIV); // 0xD5
    OLED_command(0x80);               // the suggested ratio 0x80

    // Hardware configuration

    OLED_command(SETSTARTLINE | 0x00); // line #0

    OLED_command(SEGREMAP | 0x1);     // Symétrie horizontal

	OLED_command(SETMULTIPLEX);       // 0xA8
    #ifdef OLED_HEIGHT == 64
        OLED_command(0x3F);               // 0x3F = 128x64 pixels
    #elif OLED_HEIGHT == 32
        OLED_command(0x1F);               // 0x1F = 128x32 pixels
    #endif

    OLED_command(SETDISPLAYOFFSET);   // 0xD3
    OLED_command(0);                  // no offset  

    OLED_command(SETCOMPINS);         // 0xDA
    OLED_command(0x12);               // Alternative COM pin configuration -> source du problème 1 pixel sur 2

    // 
	
	#ifdef OLED_EXTERNAL_VCC
		OLED_command(SETPRECHARGE);       // 0xd9
		OLED_command(0x22); // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT
		OLED_command(CHARGEPUMP);         // 0x8D
		OLED_command(0x10);               // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT ELSE 0x14
	#elif OLED_INTERNAL_VCC
		OLED_command(SETPRECHARGE);       // 0xd9
		OLED_command(0xF1); // VCC GENERATED BY INTERNAL DC/DC CIRCUIT
		OLED_command(CHARGEPUMP);         // 0x8D
		OLED_command(0x14);               // VCC GENERATED BY INTERNAL DC/DC CIRCUIT
	#endif
    Delay1KTCYx(1);

    OLED_command(MEMORYMODE);         // 0x20
    OLED_command(HORIZONTAL);         // 0x0 Horizontal

    OLED_command(COMSCANDEC);
    
    OLED_command(SETCONTRAST);        // 0x81
    OLED_command(0x8F);

    OLED_command(SETVCOMDETECT);      // 0xDB
    OLED_command(0x40);

    OLED_command(DISPLAYALLON_RESUME);// 0xA4

    OLED_command(NORMALDISPLAY);      // 0xA6

    OLED_command(DISPLAYON);

	OLED_command(PAGEADDR); // This display has x pages (8 bits / page vertical)
	#ifdef OLED_HEIGHT == 64
		OLED_command(0); // 8x8 = 64 pixels/bits vertical
		OLED_command(7);
	#elif OLED_HEIGHT == 32
		OLED_command(0); // 4x8 = 32 pixels/bits vertical
		OLED_command(3);
	#endif

	OLED_command(COLUMNADDR);
	#ifdef OLED_WIDTH == 128
    OLED_command(0);
    OLED_command(127); // This display has 128 columns (128 pixels/bits horizontal)
	#endif

    OLED_clear();
}

void OLED_command(char command)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_CMD); // Send command incomming
    I2CSend(command); // Send command
    I2CStop();
	Delay1KTCYx(1); // tempo = 10 * 1000 * Tcycle = 4ms -> Tcycle = (1/Fosc) * 4 = 4µs with Fosc = 1MHz
}

void OLED_data(char data)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_DATA); // Send data incomming
    I2CSend(data); // Send data
    I2CStop();
}

void OLED_clear(void)
{
   int i;

   I2CStart();
   I2CSend(I2C_ADDRESS);
   I2CSend(I2C_DATA);

   for(i=0; i < 1023; i++) // 1024 = 128 * 64/8
   {
       I2CSend(0x00);
   }

   I2CStop();
}

void OLED_char(char character, unsigned char font)
{
    unsigned char i;

    if(font == FONT_5X8)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 5; i++)
        {
            I2CSend(FONT_5x8[character - 0x20][i]);
        }
        I2CSend(0x00); // pour espacer les caractères

        I2CStop();
    }

    else if(font == FONT_8X16)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 16; i++)
        {
            I2CSend(FONT_8x16[character - 0x20][i]);
        }
        I2CSend(0x00); // pour espacer les caractères
        I2CSend(0x00);
        
        I2CStop();
    }
    
    else if(font == FONT_NUMBERS_21X32)
    {
    	I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 85; i++)
        {
            I2CSend(FONT_NUMBERS_21x32[(character - 0x30)*84+i]); // only number
        }
     
        I2CStop();
    }
}

void OLED_string(char* string, unsigned char x, unsigned char y, unsigned char font)
{
    unsigned char i = 0;

    OLED_pos(x, y);

    while(string[i] != '\0')
    {
        if(font == FONT_5X8)
        {
            OLED_char(string[i++], FONT_5X8);
        }

        else if(font == FONT_8X16)
        {
            OLED_command(PAGEADDR); // set page address
            OLED_command(y); // start at page 0
            OLED_command(y+1); // end at page 1
            OLED_command(MEMORYMODE);
            OLED_command(VERTICAL); // Vertical adressing mode
			
            OLED_char(string[i++], FONT_8X16);
        }
        
        else if(font == FONT_NUMBERS_21X32)
        {
            OLED_command(PAGEADDR); // set page address
            OLED_command(y); // start at page 0
            OLED_command(y+3); // end at page 3
            OLED_command(MEMORYMODE);
            OLED_command(VERTICAL); // Vertical adressing mode
			
            OLED_char(string[i++], FONT_NUMBERS_21X32);
        }
    }
    OLED_command(PAGEADDR); // set page address
    OLED_command(0); // start at page 0
    OLED_command(7); // end at page 7
    OLED_command(MEMORYMODE);
    OLED_command(HORIZONTAL); // Horizontal adressing mode
}

// 128 columns + 4 rows
// xmin=0, xmax=127
// ymin=0, ymax=3
// 4 pages / 1 page = 1 byte with LSB high and MSB low
void OLED_pos(char x, char y)
{
    char low_column=0;
    char high_column=0;
    char page=0;

    page=y|0xB0;
    low_column=x&0x0F;
    high_column=x&0xF0;
    high_column>>=4;
    high_column|=0x10;

    OLED_command(MEMORYMODE);
    OLED_command(PAGE); // Page adressing mode
    OLED_command(low_column); // Set lower colomn
    OLED_command(high_column); // Set higher colomn
    OLED_command(page); // Set RAM page
    OLED_command(MEMORYMODE);
    OLED_command(HORIZONTAL); // Horizontal adressing mode
}

void OLED_bmp(char sel)
{
    int i = 0;

    if (sel == LOGO)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS); // Send slave address
        I2CSend(I2C_DATA); // Send data incomming

        for(i=0; i < 1023; i++)
        {
            I2CSend(FONT_LOGO[i]);
        }

        I2CStop();
    }
}

void OLED_invert(void)
{
    OLED_command(INVERTDISPLAY);
}

void OLED_rscroll(char start, char stop)
{	
    OLED_command(0x26); // right scroll
    OLED_command(0X00); // dummy byte
    OLED_command(start); // start page
    OLED_command(0X00); // time interval = 5 frames
    OLED_command(stop); // end page
    OLED_command(0X00);
    OLED_command(0XFF);
	OLED_command(0X2F); // activate scroll
}

void OLED_lscroll(char start, char stop)
{
    OLED_command(0x27); // left scroll
    OLED_command(0X00); // dummy byte
    OLED_command(start); // start page
    OLED_command(0X00); // time interval = 5 frames
    OLED_command(stop); // end page
    OLED_command(0X00);
    OLED_command(0XFF);
	OLED_command(0X2F); // activate scroll
}

void OLED_stopscroll(void)
{
    OLED_command(0x2E);
}
