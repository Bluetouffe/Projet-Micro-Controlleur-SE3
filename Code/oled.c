#include <p18f4520.h>
#include <delays.h>
#include "oled.h"

void I2CInit(void)
{
    SSPCON1 = 0x28; // Control register configures the SDA (RC4) and SCL (RC3) pins
    SSPCON2 = 0x00; // Control register with ACK, start/stop bit
    SSPADD = 0x09;  // SSP in Master mode -> clock = FOSC/(4 * (SSPADD + 1)) Fosc=1MHz / Fcy=250kHz -> BRG=0x09 -> Fscl=25kHz
    SSPMSK = 0x00;  // Address mask The received address bit n is not used to detect I2C address match
}

void I2CStart(void)
{
    SSPCON2bits.SEN = 1;    // I2C Start condition
    while(SSPCON2bits.SEN); // SSPIF is set -> wait the required start time before any other operation takes place
}

void I2CStop(void)
{
    SSPCON2bits.PEN = 1;
    while(SSPCON2bits.PEN); // Stop I2C
}

void I2CSend(char data)
{
    SSPBUF = data;         // Serial Receive/Transmit Buffer
    while(SSPSTATbits.BF); // Wait until buffer is cleared
    //while(SSPCON2bits.ACKSTAT); // Wait until ACK is received
}

void OLED_command(char command)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_CMD);     // Send command incomming
    I2CSend(command);     // Send command
    I2CStop();
    Delay1KTCYx(1);       // tempo = 1 * 1000 * Tcycle = 1ms -> Tcycle = (1/Fosc) * 4 = 1µs (with Fosc = 250kHz)
}

void OLED_data(char data)
{
    I2CStart();
    I2CSend(I2C_ADDRESS); // Send slave address
    I2CSend(I2C_DATA);    // Send data incomming
    I2CSend(data);        // Send data
    I2CStop();
}

void OLED_Init(void)
{
    OLED_command(DISPLAYOFF);             

    OLED_command(SETDISPLAYCLOCKDIV);     
    OLED_command(0x80);                   // the suggested ratio 0x80

    OLED_command(SETMULTIPLEX);           
    #ifdef OLED_HEIGHT == 64
        OLED_command(0x3F);               // 0x3F = 128x64 pixels
    #elif OLED_HEIGHT == 32
        OLED_command(0x1F);               // 0x1F = 128x32 pixels
    #endif

    OLED_command(SETDISPLAYOFFSET);       
    OLED_command(0);                      // no offset

    OLED_command(SETSTARTLINE | 0x00);    // line #0

    #ifdef OLED_EXTERNAL_VCC
        OLED_command(SETPRECHARGE);       
        OLED_command(0x22);               // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT
        OLED_command(CHARGEPUMP);         
        OLED_command(0x10);               // VCC GENERATED BY EXTERNAL DC/DC CIRCUIT ELSE 0x14
    #elif OLED_INTERNAL_VCC
        OLED_command(SETPRECHARGE);       
        OLED_command(0xF1);               // VCC GENERATED BY INTERNAL DC/DC CIRCUIT
        OLED_command(CHARGEPUMP);         
        OLED_command(0x14);               // VCC GENERATED BY INTERNAL DC/DC CIRCUIT
    #endif

    OLED_command(SEGREMAP | 0x1);         // Symétrie horizontal

    OLED_command(COMSCANDEC);

    OLED_command(SETCOMPINS);             
    OLED_command(0x12);                   // Alternative COM pin configuration -> source du problème 1 pixel sur 2

    OLED_command(SETCONTRAST);            
    OLED_command(0x8F);

    OLED_command(SETVCOMDETECT);          
    OLED_command(0x40);

    OLED_command(DISPLAYALLON_RESUME);    

    OLED_command(NORMALDISPLAY);          

    OLED_stopscroll();
    OLED_clear();

    OLED_command(DISPLAYON);

    OLED_command(MEMORYMODE);             
    OLED_command(HORIZONTAL);             // 0x0 Horizontal

    OLED_command(PAGEADDR);               // This display has x pages (8 bits / page vertical)
    #ifdef OLED_HEIGHT == 64
            OLED_command(0);              // 8x8 = 64 pixels/bits vertical
            OLED_command(7);
    #elif OLED_HEIGHT == 32
            OLED_command(0);              // 4x8 = 32 pixels/bits vertical
            OLED_command(3);
    #endif

    OLED_command(COLUMNADDR);
    #ifdef OLED_WIDTH == 128
        OLED_command(0);
        OLED_command(127);                // This display has 128 columns (128 pixels/bits horizontal)
    #endif
}

void OLED_clear(void)
{
   int i;

   I2CStart();
   I2CSend(I2C_ADDRESS);
   I2CSend(I2C_DATA);

   for(i=0; i < 1023; i++) // 1024 = 128 * 64/8
   {
       I2CSend(0x00);
   }

   I2CStop();
}

void OLED_char(char character, unsigned char font)
{
    unsigned char i = 0;

    I2CStart();
    I2CSend(I2C_ADDRESS);  // Send slave address
    I2CSend(I2C_DATA);     // Send data incomming

    switch (font)
    {
        case FONT_5X8 :
            for(i=0; i < 5; i++)
            {
                I2CSend(FONT_5x8[character - 0x20][i]);
            }
            I2CSend(0x00);       // pour espacer les caractères
        break;
   

        case FONT_8X16 :
            for(i=0; i < 16; i++)
            {
                I2CSend(FONT_8x16[character - 0x20][i]);
            }
            I2CSend(0x00);       // pour espacer les caractères
            I2CSend(0x00);
        break;
    
        case FONT_NUMBERS_21X32 :
            for(i=0; i < 85; i++) // 21(horizontal)*4(vertical)+1
            {
                I2CSend(FONT_NUMBERS_21x32[(character - 0x30)*84+i]); // only number
            }
        break;

        case FONT_LETTERS_28X32 :
            for(i=0; i < 113; i++) // 28(horizontal)*4(vertical)+1
            {
                I2CSend(FONT_LETTERS_28x32[(character - 0x61)*112+i]); // only number
            }
        break;

        case FONT_NUMBERS_24X40 :
            for(i=0; i < 121; i++) // 24(horizontal)*5(vertical)+1
            {
                I2CSend(FONT_NUMBERS_24x40[(character - 0x30)*120+i]); // only number
            }
        break;

        default : break;
    }
    
    I2CStop();
}

void OLED_string(char* string, unsigned char x, unsigned char y, unsigned char font)
{
    unsigned char i = 0;

    OLED_pos(x, y);

    while(string[i] != '\0')
    {
        switch (font)
        {
            case FONT_5X8 :
                OLED_char(string[i++], FONT_5X8);
            break;

            case FONT_8X16 :
                OLED_command(PAGEADDR);  // set page address
                OLED_command(y);         // start at page 0
                OLED_command(y+1);       // end at page 1
                OLED_command(MEMORYMODE);
                OLED_command(VERTICAL);  // Vertical adressing mode
                OLED_char(string[i++], FONT_8X16);
            break;
        
            case FONT_NUMBERS_21X32 :
                OLED_command(PAGEADDR); // set page address
                OLED_command(y);        // start at page 0
                OLED_command(y+3);      // end at page 3
                OLED_command(MEMORYMODE);
                OLED_command(VERTICAL); // Vertical adressing mode
                OLED_char(string[i++], FONT_NUMBERS_21X32);
            break;

            case FONT_LETTERS_28X32 :
                OLED_command(PAGEADDR); // set page address
                OLED_command(y);        // start at page 0
                OLED_command(y+3);      // end at page 3
                OLED_command(MEMORYMODE);
                OLED_command(VERTICAL); // Vertical adressing mode
                OLED_char(string[i++], FONT_LETTERS_28X32);
            break;

            case FONT_NUMBERS_24X40 :
                OLED_command(PAGEADDR); // set page address
                OLED_command(y);        // start at page 0
                OLED_command(y+4);      // end at page 4
                OLED_command(MEMORYMODE);
                OLED_command(VERTICAL); // Vertical adressing mode
                OLED_char(string[i++], FONT_NUMBERS_24X40);
            break;

            default : break;
        }
    }
    OLED_command(PAGEADDR);   // set page address
    OLED_command(0);          // start at page 0
    OLED_command(7);          // end at page 7
    OLED_command(MEMORYMODE);
    OLED_command(HORIZONTAL); // Horizontal adressing mode
}

// 128 columns + 8 rows
// xmin=0, xmax=127
// ymin=0, ymax=7
// 8 pages / 1 page = 1 byte with LSB high and MSB low
void OLED_pos(char x, char y)
{
    char low_column=0;
    char high_column=0;
    char page=0;

    page=y|0xB0;
    low_column=x&0x0F;
    high_column=x&0xF0;
    high_column>>=4;
    high_column|=0x10;

    OLED_command(MEMORYMODE);
    OLED_command(PAGE);         // Page adressing mode
    OLED_command(low_column);   // Set lower colomn
    OLED_command(high_column);  // Set higher colomn
    OLED_command(page);         // Set RAM page
    OLED_command(MEMORYMODE);
    OLED_command(HORIZONTAL);   // Horizontal adressing mode
}

void OLED_bmp(char sel)
{
    int i = 0;

    if (sel == LOGO)
    {
        I2CStart();
        I2CSend(I2C_ADDRESS);   // Send slave address
        I2CSend(I2C_DATA);      // Send data incomming

        for(i=0; i < 1023; i++)
        {
            I2CSend(FONT_LOGO[i]);
        }
    }

    else if (sel == CAR)
    {
        OLED_command(PAGEADDR); // set page address
        OLED_command(5);        // start at page 0
        OLED_command(7);        // end at page 2
        OLED_command(MEMORYMODE);
        OLED_command(VERTICAL); // Vertical adressing mode

        I2CStart();
        I2CSend(I2C_ADDRESS);   // Send slave address
        I2CSend(I2C_DATA);      // Send data incomming

        for(i=0; i < 189; i++) // 63 x 3 + 1
        {
            I2CSend(FONT_CAR[i]);
        }     
    }
    
    I2CStop();
}

void OLED_invert(void)
{
    OLED_command(INVERTDISPLAY);
}

void OLED_rscroll(char start, char stop)
{
    OLED_command(0x26); // right scroll
    OLED_command(0X00); // dummy byte
    OLED_command(start); // start page
    OLED_command(0X04); // time interval = 3 frames
    OLED_command(stop); // end page
    OLED_command(0X00);
    OLED_command(0XFF);
    OLED_command(0X2F); // activate scroll
}

void OLED_lscroll(char start, char stop)
{
    OLED_command(0x27); // left scroll
    OLED_command(0X00); // dummy byte
    OLED_command(start); // start page
    OLED_command(0X04); // time interval = 3 frames
    OLED_command(stop); // end page
    OLED_command(0X00);
    OLED_command(0XFF);
    OLED_command(0X2F); // activate scroll
}

void OLED_stopscroll(void)
{
    OLED_command(0x2E);
}
